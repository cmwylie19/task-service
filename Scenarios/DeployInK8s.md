# Deploy Application in Kubernetes

_This scenario is a prereq scenerio. It is not mandatory for the other scenerios. It is created to show you how to deploy the task-service application in Kubernetes. It will walk through building a container from a Dockerfile. Pushing the built container into a Container Reguistry (DockerHub in this case), deploying the application into kubernetes, and exposing a service to the outside world and clean it up when done._

## Prereqs

- Docker
- Kuberentes (_This guide assumes you already have access to a cluster running locally, like Docker for Desktop (with Kubernetes enabled), Kind or MiniKube._)
- kubectl

_I am using Docker Desktop with kubernetes enabled._

```
$ kubectl version
Client Version: version.Info{Major:"1", Minor:"20", GitVersion:"v1.20.0", GitCommit:"af46c47ce925f4c4ad5cc8d1fca46c7b77d13b38", GitTreeState:"clean", BuildDate:"2020-12-13T19:50:45Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"darwin/amd64"}
Server Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.3", GitCommit:"1e11e4a2108024935ecfcb2912226cedeafd99df", GitTreeState:"clean", BuildDate:"2020-10-14T12:41:49Z", GoVersion:"go1.15.2", Compiler:"gc", Platform:"linux/amd64"}
```

## Overview

- Create container from the source code with a Dockerfile and push to external registry
- Create a Kubernetes deployment using `kubectl`
- Expose a service in Kubernetes using `kubectl`
- Deploy the application from a yaml manifest
- Cleanup

### Create container from the source code with a Dockerfile and push to external registry

The very first part of the deployment of `task-service` is to build a container. We will build the container using docker and give it a specific name. This part is amongst the most important to get right or you will not be able to push your container to the container registry. Tag your image with the format of [container-registry]/[username]/[app-name].

- [container-registry] is the container registry where you are going to push your image, `docker.io` or `quay.io` are a couple of options
- [username] is your username for the container registry
- [app-name] is the name of your image

We are going to deploy our application to Dockerhub.

The first step that you must do is log into dockerhub to go ahead and get that out of the way.

```
docker login
```

Now that you are logged into dockerhub, we can go ahead and build our container locally. We are going to build the container from the `Dockerfile` in the source. It is important to play close attention to the tagging system when we build the container, we need to specify the external image registry, which is this case will be dockerhub, denoted by `docker.io`, the username for the container registry, in this case `cmwylie19`, and the name of the application, in this case `task-service`. Below is the command to build the container with the appropriately tag for my user, `cmwylie19` on dockerhub:

```
docker build -t docker.io/cmwylie19/task-service .
```

At this point you should have a container in your local docker registry. Now it is time to push the container image to the external registry. The push syntax is `docker push {name-of-image}`:

```
docker push docker.io/cmwylie19/task-service
```

### Create a deployment in Kubernetes using kubectl

A quick way to create a deployment in kubernetes is by using `kubectl`.
We simply need to create a name for the deployment, in this case, task-service, and point to the image from which we want to create the deployment, in this case `docker.io/cmwylie19/task-service`.

```
kubectl create deployment task-service --image=docker.io/cmwylie19/task-service:latest
```

Verify your deployment is up and available with:

```
kubectl get deployments task-service
```

According to devops best practices you should always export your configuration as code. The way to export the deployment to yaml is:

```
kubectl get deployments task-service -o yaml > deployment-taskservice.yaml
```

Now that you have exported the deployment to yaml, you will need to sanitize it, which means getting rid of the unnecessary autogenerated field, like status, metadata.generation, metadata.creationTimestamp, metadata.uid, metadata.selfLink, metadata.resourceVersion. This scenario is not about sanitizing yaml but you should google it if you do not know how to.

### Create a service

Now that we have our deployment created, we can expose a service from it. We will use `kubectl expose`, and give the service a type `LoadBalancer` which indicates that we are exposing our service outside of the cluster.

 _In later scenarios this will not be necessary because we will use an ingress gateway_. For now, in order to use our simple app, we must create a service.

```
kubectl expose deployment task-service --type=LoadBalancer --port=8080
```

Check the status of the service with the following command:

```
kubectl get svc task-service
```

### Test out the application

Now that we have create a service of type LoadBalancer we can try and curl our application to test:

Lets create a task:

```
curl -X POST -H "Content-Type: application/json" -d '{"name":"test"}' http://localhost:8080/create
```
expected output should resemble the output below, with a different id:
```
Created{
  "id": "18f5a03088a",
  "name": "test",
  "complete": false
}%  
```

If you received a similar output then you are on the right track! 

### Clean Up

Now we will clean up the deployment and the service. We will use them again in other scenarios but we will deploy them from yaml when we do.

Delete the deployment and Service:

```
kubectl delete deployment,svc task-service
```
